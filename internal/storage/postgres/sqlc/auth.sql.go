// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: auth.sql

package sqlc

import (
	"context"
	"time"
)

const createUserSession = `-- name: CreateUserSession :exec
INSERT INTO refresh_sessions (user_id, app_id, device_id, refresh_token, last_login_at, expires_at)
VALUES ($1, $2, $3, $4, $5, $6)
`

type CreateUserSessionParams struct {
	UserID       string    `db:"user_id"`
	AppID        int32     `db:"app_id"`
	DeviceID     string    `db:"device_id"`
	RefreshToken string    `db:"refresh_token"`
	LastLoginAt  time.Time `db:"last_login_at"`
	ExpiresAt    time.Time `db:"expires_at"`
}

func (q *Queries) CreateUserSession(ctx context.Context, arg CreateUserSessionParams) error {
	_, err := q.db.Exec(ctx, createUserSession,
		arg.UserID,
		arg.AppID,
		arg.DeviceID,
		arg.RefreshToken,
		arg.LastLoginAt,
		arg.ExpiresAt,
	)
	return err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, app_id, updated_at
FROM users
WHERE email = $1
  AND app_id = $2
  AND deleted_at IS NULL
`

type GetUserByEmailParams struct {
	Email string `db:"email"`
	AppID int32  `db:"app_id"`
}

type GetUserByEmailRow struct {
	ID        string    `db:"id"`
	Email     string    `db:"email"`
	AppID     int32     `db:"app_id"`
	UpdatedAt time.Time `db:"updated_at"`
}

func (q *Queries) GetUserByEmail(ctx context.Context, arg GetUserByEmailParams) (GetUserByEmailRow, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, arg.Email, arg.AppID)
	var i GetUserByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.AppID,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, email, app_id, updated_at
FROM users
WHERE id = $1
  AND app_id = $2
  AND deleted_at IS NULL
`

type GetUserByIDParams struct {
	ID    string `db:"id"`
	AppID int32  `db:"app_id"`
}

type GetUserByIDRow struct {
	ID        string    `db:"id"`
	Email     string    `db:"email"`
	AppID     int32     `db:"app_id"`
	UpdatedAt time.Time `db:"updated_at"`
}

func (q *Queries) GetUserByID(ctx context.Context, arg GetUserByIDParams) (GetUserByIDRow, error) {
	row := q.db.QueryRow(ctx, getUserByID, arg.ID, arg.AppID)
	var i GetUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.AppID,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserData = `-- name: GetUserData :one
SELECT id, email, password_hash, app_id, updated_at
FROM users
WHERE id = $1
  AND app_id = $2
  AND deleted_at IS NULL
`

type GetUserDataParams struct {
	ID    string `db:"id"`
	AppID int32  `db:"app_id"`
}

type GetUserDataRow struct {
	ID           string    `db:"id"`
	Email        string    `db:"email"`
	PasswordHash string    `db:"password_hash"`
	AppID        int32     `db:"app_id"`
	UpdatedAt    time.Time `db:"updated_at"`
}

func (q *Queries) GetUserData(ctx context.Context, arg GetUserDataParams) (GetUserDataRow, error) {
	row := q.db.QueryRow(ctx, getUserData, arg.ID, arg.AppID)
	var i GetUserDataRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.AppID,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserDeviceID = `-- name: GetUserDeviceID :one
SELECT id
FROM user_devices
WHERE user_id = $1
  AND user_agent = $2
  AND detached = FALSE
`

type GetUserDeviceIDParams struct {
	UserID    string `db:"user_id"`
	UserAgent string `db:"user_agent"`
}

func (q *Queries) GetUserDeviceID(ctx context.Context, arg GetUserDeviceIDParams) (string, error) {
	row := q.db.QueryRow(ctx, getUserDeviceID, arg.UserID, arg.UserAgent)
	var id string
	err := row.Scan(&id)
	return id, err
}

const getUserStatus = `-- name: GetUserStatus :one
SELECT CASE
WHEN EXISTS(
    SELECT 1
    FROM users
    WHERE users.email = $1
      AND deleted_at IS NULL FOR UPDATE
    ) THEN 'active'
    WHEN EXISTS(
    SELECT 1
    FROM users
    WHERE users.email = $1
      AND deleted_at IS NOT NULL FOR UPDATE
    ) THEN 'soft_deleted'
ELSE 'not_found' END AS status
`

func (q *Queries) GetUserStatus(ctx context.Context, email string) (string, error) {
	row := q.db.QueryRow(ctx, getUserStatus, email)
	var status string
	err := row.Scan(&status)
	return status, err
}

const insertUser = `-- name: InsertUser :exec
INSERT INTO users (id, email, password_hash, app_id,updated_at)
VALUES ($1, $2, $3, $4, $5)
`

type InsertUserParams struct {
	ID           string    `db:"id"`
	Email        string    `db:"email"`
	PasswordHash string    `db:"password_hash"`
	AppID        int32     `db:"app_id"`
	UpdatedAt    time.Time `db:"updated_at"`
}

func (q *Queries) InsertUser(ctx context.Context, arg InsertUserParams) error {
	_, err := q.db.Exec(ctx, insertUser,
		arg.ID,
		arg.Email,
		arg.PasswordHash,
		arg.AppID,
		arg.UpdatedAt,
	)
	return err
}

const registerDevice = `-- name: RegisterDevice :exec
INSERT INTO user_devices (id, user_id, app_id, user_agent, ip, detached, last_login_at)
VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type RegisterDeviceParams struct {
	ID          string    `db:"id"`
	UserID      string    `db:"user_id"`
	AppID       int32     `db:"app_id"`
	UserAgent   string    `db:"user_agent"`
	Ip          string    `db:"ip"`
	Detached    bool      `db:"detached"`
	LastLoginAt time.Time `db:"last_login_at"`
}

func (q *Queries) RegisterDevice(ctx context.Context, arg RegisterDeviceParams) error {
	_, err := q.db.Exec(ctx, registerDevice,
		arg.ID,
		arg.UserID,
		arg.AppID,
		arg.UserAgent,
		arg.Ip,
		arg.Detached,
		arg.LastLoginAt,
	)
	return err
}

const setDeletedUserAtNull = `-- name: SetDeletedUserAtNull :exec
UPDATE users
SET deleted_at = NULL
WHERE email = $1
`

func (q *Queries) SetDeletedUserAtNull(ctx context.Context, email string) error {
	_, err := q.db.Exec(ctx, setDeletedUserAtNull, email)
	return err
}

const updateLatestLoginAt = `-- name: UpdateLatestLoginAt :exec
UPDATE user_devices
SET last_login_at = $1
WHERE id = $2
  AND app_id = $3
`

type UpdateLatestLoginAtParams struct {
	LastLoginAt time.Time `db:"last_login_at"`
	ID          string    `db:"id"`
	AppID       int32     `db:"app_id"`
}

func (q *Queries) UpdateLatestLoginAt(ctx context.Context, arg UpdateLatestLoginAtParams) error {
	_, err := q.db.Exec(ctx, updateLatestLoginAt, arg.LastLoginAt, arg.ID, arg.AppID)
	return err
}
